###### Start performance timer
set tStart [clock clicks -milliseconds]

###### Load libraries

# Load the VTK package for visualization
package require vtk

# Stop Tk from popping up an empty window
#wm withdraw .

package require FullMonte 1.0


###### Set file names and load files
set datapath "@FULLMONTE_DATA_DIR@/MMC/Colin27"

if { $argc >= 1} {
        set N [lindex $argv 0]
	if { $argc > 1} {
        set datapath [lindex $argv 1]
	}
} else {
        puts "The colin27_fluence.tcl script requires at least 1 input."
        puts "For example, ./tclmonte.sh colin27_fluence.tcl 5 <datapath>."
        puts "Please try again."
	exit 1
}

set meshfn "$datapath/Colin27.mesh"
set optfn  "$datapath/Colin27.opt"


TIMOSMeshReader R

R filename $meshfn
R read
set mesh [R mesh]

TIMOSMaterialReader MR
MR filename $optfn
MR read
set opt [MR materials]


set tLoaded [clock clicks -milliseconds]


# Create and place source (units are mm, referenced to the input geometry)
# This placement was derived by loading the mesh in Paraview and manipulating a point source
Point P
P position "90.77090454101562 170.47908742804466 124.069055680822278"
Point P2
P2 position "41 50 110"
Composite C
C add P
C add P2
Ball B
B centre "90.77090454101562 170.47908742804466 124.069055680822278"
B radius 3


###### Instantiate and configure simulation kernel
TetraVolumeKernel k

# Kernel properties
    k source B
	# the source to launch from

    k geometry $mesh
	# mesh

    k materials $opt
	# materials

# Monte Carlo kernel properties (standard, unlikely to need change)
    k roulettePrWin      0.1
	# probability of roulette win

    k rouletteWMin       1e-5
	# minimum weight "wmin" before roulette takes effect

    k maxSteps           10000
    k maxHits            10000

# Number of packets to simulate. More -> higher quality, longer run time. Try 10^6 to start.
    k packetCount        1000000

# Thread count should be number of cores on the machine, or 2x number of cores with SMT (aka. "Hyperthreading")
    k threadCount        8


proc progresstimer {} {
    # loop until kernel is done
	while { ![k done] } {
    	puts -nonewline [format "\rProgress %6.2f%%" [expr 100.0*[k progressFraction]]]
	    flush stdout

        # wait 200ms
    	after 200
	}
	puts [format "\rProgress %6.2f%%" 100.0]
}



###### Select the internal surfaces for fluence counting

# bidirectional=1 -> count fluence entering and exiting
#TriFilterRegionBounds TF
#    TF mesh $mesh
#    TF bidirectional 1
#    TF includeRegion 1 1

#TetraFilterByRegion TETF
#	TETF mesh $mesh
#	TETF excludeAll
#	TETF include 1 1

#$mesh setFacesForFluenceCounting TF



###### Output conversion and processing

# Convert energy absorbed in each tetra to fluence (divide by area*mu_a)
EnergyToFluence EFV
	EFV mesh $mesh
	EFV materials $opt


###### VTK file write pipeline

# Make FullMonte mesh data structure available to VTK
vtkFullMonteTetraMeshWrapper VTKM
    VTKM mesh $mesh


### VOLUME DATA

vtkFullMonteArrayAdaptor vtkPhiV

# vtkFieldData stores multiple named arrays which hold one entry per geometry element (here, tetrahedron)
# first add an array "Tissue Type" from the mesh regions
# we will later add fluence for each tetrahedral volume element
vtkFieldData volumeFieldData
    volumeFieldData AddArray [VTKM regions]

# data object holds the field data
vtkDataObject volumeDataObject
    volumeDataObject SetFieldData volumeFieldData

# Merge the mesh geometry with the field data object
vtkMergeDataObjectFilter mergeVolume
    mergeVolume SetDataObjectInputData volumeDataObject
    mergeVolume SetInputData [VTKM blankMesh]
    mergeVolume SetOutputFieldToCellDataField

# write the resulting volume data to a file
vtkUnstructuredGridWriter VW
    VW SetInputConnection [mergeVolume GetOutputPort]
#    VW SetFileName "colin27.vtk"



###### Run experiments

for {set i 0} {$i < $N} {incr i} {
	puts "Trial $i of $N"

	k randSeed $i
	# set the random seed

	# start the kernel, show the progress timer, and wait until the kernel is done
	k startAsync
	    progresstimer
		k finishAsync

	puts "Kernel is done"
	
	# OutputDataSummarize OS
	set ODC [k results]

	# update volume fluence converted with volume absorption data, write to file
	EFV source [$ODC getByIndex 2]
	EFV update

	vtkPhiV source [EFV result]
	volumeFieldData AddArray [vtkPhiV array]

	VW SetFileName "../Examples/Data/colin27/FullMonte_fluence_ball_$i.vtk"
#	VW SetFileTypeToBinary
	VW Update
	volumeFieldData RemoveArray [vtkPhiV array]
	puts "Trial $i of $N Complete"
}

## Added exit to avoid pop up tcl window after running 
exit
